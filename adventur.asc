'
' MSX ADVENTURE (L) Diogo Ferreira da Costa Patrão 2023
' 
' Este programa é um software livre; você pode redistribuí-lo e/ou
' modificá-lo sob os termos da Licença Pública Geral GNU como publicada
' pela Free Software Foundation; na versão 3 da Licença, ou
' (a seu critério) qualquer versão posterior.
' 
' Este programa é distribuído na esperança de que possa ser útil,
' mas SEM NENHUMA GARANTIA; sem uma garantia implícita de ADEQUAÇÃO
' a qualquer MERCADO ou APLICAÇÃO EM PARTICULAR. Veja a
' Licença Pública Geral GNU para mais detalhes.
'
' Você deve ter recebido uma cópia da Licença Pública Geral GNU junto
' com este programa. Se não, veja <http://www.gnu.org/licenses/>.
'
' ---
'
' This program is free software: you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation, either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program.  If not, see <https://www.gnu.org/licenses/>.

' 0 - sprites (0) ResSprte
FILE "adv16tiny.spr"

' 1- tela do castelo (1)ResCastle
FILE "adv.sc1"

' 2- telas de labirinto (2-17) ResLayouts
FILE "maze0a.sc1"
FILE "maze1a.sc1"
FILE "maze2a.sc1"
FILE "maze3a.sc1"
FILE "maze4a.sc1"
FILE "maze5a.sc1"
FILE "maze6a.sc1"
FILE "maze7a.sc1"
FILE "maze8a.sc1"
FILE "maze9a.sc1"
FILE "mazeaa.sc1"
FILE "mazeba.sc1"
FILE "mazeca.sc1"
FILE "mazeda.sc1"
FILE "mazeea.sc1"
FILE "mazefa.sc1"
FILE "ROOMS\EASTER.sc1" ' 18 sala easter egg

' aqui vou colocar as fases do templo e outros 
' 19 sala do dragao abrindo a boca
FILE "temple\room_13.sc1"

' 20 sala do dragao (147)
FILE "temple\room_11.sc1"

' 21 labirinto #0 - game 4
FILE "rooms\maze4_0.sc1"

' 22 labirinto #1 - game 4
FILE "rooms\maze4_1.sc1"

' 23 labirinto #2 - game 4
FILE "rooms\maze4_2.sc1"

' 24 labirinto #3 - game 4
FILE "rooms\maze4_3.sc1"

' 25 labirinto #4 - game 4
FILE "rooms\maze4_4.sc1"

' 26 labirinto #5 - game 4
FILE "rooms\maze4_5.sc1"

' 27 (ResChrTitle)
FILE "data\title.bin"

' 28 - musicas do jogo (introdução, portal e vitória) ResOpeningSong
FILE "music\intro.akm"

' 29 - tela de abertura do jogo (ResTitleScreen)
FILE "title\title.sc2"

' 30- ResRooms
FILE "data\ROOM0.bin"

' 31 (jogo 1)
FILE "data\ROOM1.bin"

' 32 (jogo 2 e 3)
FILE "data\ROOM2.bin"

' 33 (jogo 4)
FILE "data\ROOM3.bin"

' 34 ResObjects
FILE "data\OBJECTS0.bin"

' 35 (jogo 1)
FILE "data\OBJECTS1.bin"

' 36 (jogo 2 e 3)
FILE "data\OBJECTS2.bin"

' 37 (jogo 4)
FILE "data\OBJECTS3.bin"

' 38 ResObjPref
FILE "data\OBJ_PREF.bin"

' 39 ObjetoSalaFlag
FILE "data\ObjetoSalaFlag.bin"

' 40 Efeitos Sonoros
FILE "music\effects.akx"

'
' início do código
'
'
'
1 DEFINT A-Z
2 CMD TURBO 0  ' senao a musica fica bugada

' carrega tela de abertura
10 SCREEN 2,2,0
11 CMD PLYLOAD 28, 40 ' ResOpeningSong, Efeitos Sonoros
12 CMD PLYSONG 0: CMD PLYPLAY
13 SCREEN LOAD 29 ' ResTitleScreen
15 if strig(0) = 0 and strig(1) = 0 then 15
16 CMD PLYSONG 3: CMD PLYPLAY ' silencio

' inicializa tela do jogo
20 SCREEN 1,2,0
21 WIDTH 32
22 KEYOFF
23 COLOR 15,14,14

24 RANDOMIZE

'
' definicoes de arrays
'

	' sala
30 DIM RL(31),RC(31),RS(31),RN(31),RO(31),RE(31),RF(31) 

	' objetos
35 DIM OL(18),OX(18),OY(18),OC(18),OS(18),OH(18),OW(18),OA(18) 

	' Relaciona objeto (indice) com flags - bits no RF da sala => salas onde o objeto não pode ter sua posição inicial randomizada
39 Dim ObjetoSalaFlag(10)


	' velocidade das criaturas
40 DIM VX(18),VY(18) 

	' easter egg - labirinto com pontinhos do pacman
	' PacManSc( sala, tela )
41 Dim PacManSc( 384, 4 )

	' ?
42 DIM PO(14) 


43 PacManCount = 0

	' reacao a objetos (apenas dragoes)
45 DIM PC(9,5) 

	' objetos na sala atual
50 DIM SO(10) 

	' guardamos a tela aqui para o labirinto invisivel e colisao
51 DIM sc(16,22) 

' conquistas (caracteres: 141-146)
' 0- pacifista (sem matar nenhum dragao)
' 1- seu jorge por favor me empresta o dragao (matou todos dragoes)
' 2- easter egg
' 3- atraído (atraiu a taça pra dentro do castelo)
' 4- acumulador (acumulou todos os objetos no castelo)
' 5- terceirização (o morcego levou a taça pro castelo)
' 6- passeio (voou na barriga do dragao levado pelo morcego)
' 7- terminou o jogo IV
52 DIM Conquistas(7)

	' le telas, sprites, caracteres e efeitos sonoros
54 GOSUB 8000

	' Sala onde o cursor vai começar (se isso é diferente de -1, começa na sala especificada)
58 StartAtOtherRoom = -1

	' inicializa mapa 0
59 LV = 0: AL = 0: GOSUB 9000


'
' variaveis globais
' cai aqui tambem para iniciar um novo nivel
'
	
	' efeito sonoro (qual) e contador
60  IF LV=0 AND StartAtOtherRoom = 9 THEN  CMD PLYSONG 4: CMD PLYPLAY 
61  BatSpeed    = 4 ' 2 * SpeedMultiplier ' velocidade do morcego
62  CursorSpeed = 4 ' 2 * SpeedMultiplier ' velocidade em pixels / frame, do cursor 
63  DragonSpeed = 2 ' 1 * SpeedMultiplier ' velocidade em pixels / frame, do dragoes
64  MagnetSpeed = 2 ' 1 * SpeedMultiplier
70  OM = -1 ' objeto que o morcego tá perseguindo
75  AP =  0 ' animacao da porta do castelo (8= tudo fechado 0 = tudo aberto)
85  FR =  0 ' frame (quantas vezes o loop rodou, 0-59)
95  OO = -1 ' objeto de maior prioridade na sala atual (ima)
105 CO =  0 ' colision player
107 BRBRP = -1 ' rollback da ponte - controla a volta do jogador a sala anterior se usando a ponte pra trocar de sala ele acabaria emparedado 
110 PacDots = 500 ' pontuacao da tela easter egg
115 EG =  0 ' end game trigger
116 S2Timer = 0 ' quanto tempo está apertando botao 1 + botao 2 ao mesmo tempo

' dragao gigante
117 ContaDragao = 0

' matança de dragoes neste nível
118 DragoesMortos = 0

	' cursor x and y
120 XP = 76 : YP = 160 : UX = XP : UY = YP

	' Room of Player
121	if StartAtOtherRoom <> -1 THEN RP = StartAtOtherRoom: StartAtOtherRoom = -1: GOTO 123
122 IF LV =0 THEN RP = 0 ELSE RP = 1

	' objeto carregado, distancia X e Y para o cursor
123 OP = -1 : DeltaOpX = 0: DeltaOpY = 0 


130 CALCULAPRIORIDADES=0 ' marcador para quando precisa executar rotinas para escolher a prioridade dos dragoes e do ima

	' aleatoriza posicao de objetos no mapa
150 IF AL=1 THEN GOSUB 7210

	' desenha tela
160 GOSUB 7000

	' define cores dos tiles do logotipo (cinza sobre preto - 16 + 14)
170 FOR I=24 to 31:VPOKE BASE(6)+I, 30:NEXT I 

	' main loop
190 TS = 0: TN = 0
200 TIME=0
210 GOSUB 1000:FR=(FR+1)MOD 60
220 IF EG<>0 THEN 250
230 IF TIME < 3 THEN 230 ' SF - para sincronizar a execução do jogo
	' medição de tempo (300=3 frames de 1/60 segundos)
240 GOTO 200

	' se chegou aqui, passa para o proximo nivel
250 ON EG GOTO 260,290,300
255 END ' PRINT "FIM DE JOGO DESCONHECIDO":END

	' EG = 1 => colidiu com portal no nivel 0 => vai para nivel especificado no portal (I2)
260 IF LV=0 THEN T=OA(I2):GOSUB 7230:GOSUB 9000: CMD PLYLOOP 1: CMD PLYSONG 1: CMD PLYPLAY: goto 60 ' CMD PLYLOOP 0: 

	' colidiu com portal no nivel 2 => inicia fase easter egg - pacman
270 IF LV=2 THEN LV=0: StartAtOtherRoom=9: GOSUB 9000: GOSUB 10000: GOTO 60
280 END ' nao deveria cair aqui nunca

	' EG = 2 => colidiu com portal nos níveis 1 em diante, ou terminou jogo com taça
	' entrou no castelo com taça => vai para nivel zero e libera jogo 4
	' TODO se terminou o nivel 4, fazer uma telinha de fim de jogo + musiquinha
290 IF LV = 3 THEN Gosub 13400 ' testa conquista

	' EG = 3 => F6 (não testa fim de jogo)
300 LV=0:AL=0:GOSUB 9000
320 GOTO 60



400 ' Procedure: Libera jogo 4. Portal de jogo muda de sala
410 OA( 14 ) = 4 : OL( 14 ) = 4
420 RETURN

450 ' Procedure: Libera jogo 1. Portal de jogo muda de sala
460 OA( 14 ) = 1 : OL( 14 ) = 1
470 RETURN



'
'
' LOOP
'
'

1000 ' main

1020 ' move player
1025 A$=INKEY$: 'OUT &HAA,6 ': PressionouShift = (INP(&HA9) AND 1)=0
1030 ST=STICK(0) OR STICK(1) ' movimento - o que acontece se apertar os dois?
1033 SG=STRIG(0)+STRIG(1) ' botão 1 - solta objeto
1035 S2=0:IF SG AND STRIG(3) THEN IF S2Timer < 0 THEN S2Timer=20 ELSE S2Timer = S2Timer-1: IF S2Timer < 0 THEN S2=-1
1040 XD=0:YD=0
1041 IF A$=CHR$(246) OR ( S2 AND ST = 1 ) THEN gosub 6900:gosub 7000 ' F1 = Nova vida
1042 IF A$=CHR$(251) OR ( S2 AND ST = 5 ) AND LV > 0 THEN EG = 3: RETURN ' F6 = volta pro nivel zero

'
' debug temporário
'
' F3 muda o jogo, F4 vai pra sala
'1043 IF A$=chr$(248) THEN INPUT T: gosub 7230 : gosub 9000: goto 60 else IF A$=chr$(249) THEN INPUT RP: gosub 7000 : RETURN ELSE IF A$=chr$(250) then PacDots=10:return


	' se caiu aqui, não está no modo mira, move o personagem
1050 IF ST=0 THEN ux=xp:uy=yp:GOTO 1120
1060 IF ST=8 OR ST<3 THEN YD=-1
1070 IF ST>1 AND ST<5 THEN XD=1
1080 IF ST>3 AND ST<7 THEN YD=1
1090 IF ST>5 THEN XD=-1
1100 XP=XP+XD*CursorSpeed: UX=XP
1101 YP=YP+YD*CursorSpeed: UY=YP

'
' se é labirinto invisivel, trata aqui
'
1110 IF rf(rp) AND 2 THEN GOSUB 4000

' rotina de colisao do player com outros objetos
1120 GOSUB 2100

' bridge rollback
' este codigo precisa ficar aqui pq a rotina de colisao com mapa (2300)
' altera o valor de YD
1125 IF BRBRP <> -1 AND YD = 0 THEN IF TILE( XP\8, YP\8 ) <> 32 THEN RP = BRBRP: YP = BRBYP: BRBRP = -1: GOSUB 7000
1126 IF BRBRP <> -1 AND TILE( XP\8, YP\8 ) = 32 THEN BRBRP = -1
1127 IF ST =0 THEN 1150 

' rotina de colisao do player com mapa 
' (isso vai depois da colisao com objetos para permitir pegar objetos dentro das paredes)
1130 GOSUB 2300

	' pacman - come as bolinhas ou pisca a setinha
1140 IF LV=0 THEN IF RP>=9 AND RP<=13 AND PacDots>0 THEN GOSUB 12000 

' cai aqui se não pressionou nada no joystick

	' se esta no nivel pacman e terminou os dots, pisca a setinha e some com o dragão
1150 IF LV=0 THEN IF RP>=9 AND RP<=13 AND PacDots<=0  GOSUB 12100

	' mordida do dragão gigante
1152 IF LV<>0 OR RP<>14 THEN 1160
1153 IF RL(RP)=147 AND XP > 72 AND YP < 96 THEN RL(RP)=146: ContaDragao=20: Gosub 7000 : CMD PLYSOUND 4,0,15
1155 IF RL(RP)=146 THEN IF ContaDragao > 0 THEN ContaDragao = ContaDragao -1 ELSE RL(RP)=147: Gosub 7000: IF XP > 72 AND YP < 96 THEN CMD PLYSOUND 2,0,15: XP = 104 : YP = 104

' desenha cursor (dando aquela impressao de movimento)
1160 Gosub 5300

' rotinas para objeto carregado 
1170 IF OP = -1 then 1250

' move objeto carregado e muda se sala se necessario
1175	OLDROOM = OL(OP)
1180	OX(OP) = XP + DeltaOpX: OY(OP) = YP + DeltaOpY: OL( OP ) = RP: I1 = OP: GOSUB 7400

' se está carregando o morcego, muda de sala o objeto carregado pelo morcego
' e exibe o sprite
1181	IF OP <> 10 OR OM = -1 THEN 1185
1182		OX( OM ) = OX(10) + OW(10) + 4 : OY(OM) = OY(10) : OL( OM ) = OL( 10 )

		' se mudou de sala, recalcula prioridades
1185	NUROOM = OL(OP): IF NUROOM <> OLDROOM THEN CALCULAPRIORIDADES = 1

		' exibe objeto carregado se estiver na sala do player
1190	I7 = OP : IF OL(OP)=RP THEN X7=OX(OP):Y7=OY(OP) ELSE Y7=207
1200	GOSUB 7800



		' solta objeto se pressionou botao
1210	IF SG<>0 THEN OP=-1: CMD PLYSOUND 1, 0, 15: IF OL(4) = RP then gosub 2600 ' efeito sonoro de soltar e se estiver na sala do ima recalcula sua prioridade

1250 '

	' mudanca de sala do player
1400 GOSUB 2000

	' calcula colisao de objetos 11-13 (portas)
1500 FOR I = 11 to 13

        ' ignora porta que nao esteja na sala do cursor, portas fechadas e portas seguradas pelo cursor (hehe)
1510 	IF OL(I) <> RP OR I = OP THEN 1590

        ' ENTRAR NA PORTA: se a porta esta aberta e teve colisao com o cursor, pode entrar (TODO mudar posicao inicial para 176)
1520	I1 = -1 : I2 = I : GOSUB 6000 : IF ( OA(i) and 256 ) <> 0 AND CO THEN RP=OA(i) and 255:YP=180:GOSUB 7000: GOTO 1600

        ' ABRIR PORTAS: se a porta esta fechada e teve colisao com a chave respectiva pode abrir
1530    IF ( OA(i) and 256 ) <> 0 THEN 1590
                                                   ' desativa bit 0 - TODO utilizar apenas o ID da porta?
1540	I1 = I - 11 : I2 = I : GOSUB 6000

1550	IF NOT CO THEN 1570 

1560		RF(RP)=RF(RP) and 32766 : OA(i) = OA(i) OR 256 : AP = 8 : APF = I : OH(i) = 8 : OS(i) = 2 : GOSUB 7900 : GOTO 1600

' TODO fechar porta

1570 '

1590 NEXT I

	' sai do loop
1600 ' 

	' rotinas do portal de fase
1610 IF LV <> 0 AND LV <> 2 THEN 1640 

1615 I2 = 14

	' animação do portal (todo otimizar, mudando o os e chamando a rotina 7895 acho)
1620 	IF OL(I2) = RP THEN OS(I2) = 27 + ((fr/2) mod 4) : I7 = I2 : X7 = OX(I2): Y7=OY(I2) : GOSUB 7800

	' colisão com portal de fase (TODO animação)
1625 	I1 = -1: GOSUB 6000: IF CO THEN EG = 1: GOTO 1990

1630 	I2 = I2 + 1 : IF I2 = 15 THEN I2 = 16

1635 	IF I2 <= 17 then 1620

	' animacao da porta do castelo abrindo REFATORAR (PQ?)
1640 if AP=0 then 1650
1641 	X7=OX(APF): Y7=OY(APF)
1642 	if AP>3 then TMP=4:putsprite 23,(X7,Y7+16),1,ap-4 else TMP=ap+1:SprCamada = 23:gosub 7895
1644 	putsprite 12,(X7,Y7),1,TMP
1645 	ap=ap-1

	' pisca a taça
1650 IF OL(5)=RP OR OP=5 THEN OC(5)=((OC(5)+1)MOD 14)+1:IF OP<>5 THEN I7=5:X7=OX(5):Y7=OY(5): Gosub 7800

	' vitória: taça dentro do castelo amarelo
1660 IF ol(5)<>0 THEN 1670
1661	Gosub 13000 ' verifica conquistas
1663 	EG=2 : GOSUB 7500
1668	GOTO 1990

'
' preciso recalcular prioridades dos dragoes e imas?
'

1670 IF CALCULAPRIORIDADES = 1 THEN GOSUB 2560: GOSUB 2600: CALCULAPRIORIDADES = 0


'
'
' move DRAGOES
'
'
' local: i,j,i7,f7,pc%,i1,x7,y7
1700 FOR I=7 TO 9

' dragao: biting
1705    IF OA(I)>0 THEN OA(I)=OA(I)-1: if OA(I)=0 then I2=I: gosub 6200: goto 1790 else 1790

' dragao: morto ou de pança cheia nao se move
1710    IF OA(I) = -1 OR OA(I) = -2 THEN goto 1790 

' dragao: persegue / chase

       ' dragao seguro pelo morcego => nao anda sozinho
1711   IF OM = I then 1740

       ' acha prioridade para o dragão I (retorna em PO(I) )
1712   PRIORIDADE = PO(I)
1715   IF PRIORIDADE = 1024 THEN 1730 'nao tem prioridade - segue na mesma direção
	
	' calcula multiplicador do dragao vermelho
1717  IF I=9 THEN ThisDragonSpeed = DragonSpeed * 2 else ThisDragonSpeed = DragonSpeed
	
	' prioridade é o cursor
1720    IF PRIORIDADE = 512 THEN VX(I)=SGN(XP-OX(I))*ThisDragonSpeed:VY(I)=SGN(YP-OY(I))*ThisDragonSpeed: GOTO 1730

	' prioridade é objeto - segue ou foge (TODO : OTIMIZAR IF)
1725	IF (PRIORIDADE AND 256) <> 0 THEN F7 = -ThisDragonSpeed: PRIORIDADE = PRIORIDADE AND 255 ELSE F7 = ThisDragonSpeed

1727 	VX(I)=SGN(OX(PRIORIDADE)-OX(I)) * F7 : VY(I)=SGN(OY(PRIORIDADE)-OY(I)) * F7

	' segue na direção definida 
1730    OX(I)=OX(I)+VX(I):OY(I)=OY(I)+VY(I)

'1735    IF I = 9 THEN OX(I)=OX(I)+VX(I):OY(I)=OY(I)+VY(I)
1740    I1=I:GOSUB 7400

	' colisao com espada = morte do dragao
1750	I1 = 3 : I2 = I : GOSUB 6000 : IF NOT CO THEN 1760

	' matou o dragao
1754	DragoesMortos = DragoesMortos + 1 : OA(I) = -1 : OS(I) = -1 : OS(I) = 15 : CMD PLYSOUND 5,0,15

' conquista?
1755	Gosub 13100
1760  	IF OL(I) = RP THEN I7 = I : X7 = OX(I) : Y7=OY(I) : GOSUB 7800 ELSE I7=I : Y7=207 : GOSUB 7800


1790 NEXT I


' chama a  rotina do morcego
1795 GOSUB 5000 

' resolve a atraçao do imã
1800 GOSUB 7700


1990 RETURN

' ----------------------------------------------
'
'                   rotinas
'
' ----------------------------------------------

'
' PROCEDURE: muda o player de sala se necessário
'
2000	IF NOT( YP>=184 AND YD=1 ) THEN GOTO 2070
2020		LASTROOM = RP: RP=RS(RP):YP=YP-184:GOSUB 7000 

	' checa rollback da ponte 
2021	IF BRBRP = -1 THEN 2030
			' se atravessou a parede, mudou de sala e não tem parede bloqueando, limpa rollback
2023		IF tile( XP\8, YP\8 ) <= 127 THEN BRBRP = -1

		' TODO só permite sair se porta do castelo estiver aberta ( o que fazer com dragoes e outros bichos?)

2030	IF NOT( RL( RP ) = 128 AND ( OA( RF( RP ) \ 256 ) AND 255 ) = LASTROOM ) THEN 2060
2040 		IF OP<>-1 THEN OX(OP)=OX(OP)-(XP-78)
2050		YP=120:XP=78
2060	GOTO 2095 

' vai para sala de cima
2070   IF YP<0 AND YD=-1 THEN RP=RN(RP):YP=184+yp:GOSUB 7000:GOTO 2095

' vai para sala da direita
2080   IF XP>=160 AND XD=1 THEN RP=RE(RP):XP=0:GOSUB 7000:GOTO 2095

' vai para sala da esquerda
2090  IF XP<0 AND XD=-1 THEN RP=RO(RP):XP=156:GOSUB 7000:GOTO 2095

' fim
2095 RETURN


' Procedure: detecta e trata colisão do jogador com objetos
' MODIFICA OP 
' TODO otimizar (ideia: manter lista de objetos na sala atual)
' LOCAL: I1,I2, RECALCULA, TMPX, TMPY
' MODIFICA: OM, OA(10), OP, OX(OP),OY(OP), ES, EC, DeltaOpX, DeltaOpY
2100 I1 = -1: RECALCULA = 0 
2110 FOR I2 = 0 TO 15: if I2 >= 11 and I2<> 15 THEN 2210 ' pula portas de castelo, portal de fase e portal 
2120 	GOSUB 6000
2130 	IF CO=0 OR I2 = OP THEN 2210

' COLISAO COM DRAGAO
2140 	IF I2 >=7 AND I2 <= 9 THEN GOSUB 6100: GOTO 2210

' segura objeto (tira do morcego, se for o caso)
2150	IF OM = I2 THEN OM = -1: OA(10) = -1 : OO = I2 
2155	OP = I2: TMPX = 8*XD: TMPY=8*YD
2160	OX(OP)=OX(OP) + TMPX
2165	OY(OP)=OY(OP) + TMPY
2170	DeltaOpX = OX(OP) - XP
2175	DeltaOpY = OY(OP) - YP
2190	IF OP = 10 AND OM <> 1 THEN OX(OM)=OX(OM)+TMPX: OY(OM)=OY(OM)+TMPY

		' EFEITO SONORO DE SEGURAR
2200	CMD PLYSOUND 3,0,15 


2210 NEXT I2
2220 RETURN

' Procedure: evita obstaculos exceto se estiver na ponte. nao vale se estiver carregando a ponte
' colisão com mapa
' resolve também o teleport na fase 4
'  TODO otimizar com rotina especifica para sala vazia RL<128
' variáveis globais modificadas:
'	- XP, XD
'	- YP, YD
'   - BRBRP
' local: xi,yi,bi,bj
		' reseta rollback da ponte
2300	'BRBRP = -1
	   ' se ta na ponte indo pra cima ou pra baixo, ignora obstaculos
2305	IF YD<>0 AND XD=0 AND op<>6 THEN IF OL(6)=RP AND XP>OX(6) AND XP<OX(6)+32 AND YP+8>OY(6) AND YP<OY(6)+48 THEN 2450

		' calcula colisão com mapa
2320	XI=XP\8: XJ=(XP+2)\8 
2330	YI=YP\8: YJ=(YP+7)\8

		' teleport do jogo 4
2335	IF TILE(XI,YI) = 42 THEN RP=7:GOTO 7000 ' DOu goto e nao gosub para economizar return

2340    IF (FR MOD 2) = 0 THEN gosub 2480: gosub 2390 else gosub 2390 : gosub 2480

2350 RETURN

' CHECK Y
2390	IF YD = 0 then 2470 ELSE IF YD > 0 THEN 2420

		' YD < 0 TODO OTIMIZACAO - CONSOLIDAR O THEN DAQUI E DA LINHA DE BAIXO
2400	IF TILE( XI, YI ) > 127 OR TILE( XJ, YI ) > 127 THEN YP = YP + CursorSpeed: YD = 0: YI=YP\8: YJ=(YP+CursorSpeed)\8
2410	IF RP=5 THEN 2450 ELSE 2470 ' roda o algoritmo da ponte por causa do risco de emparedamento na sala do easter egg

		' YD > 0 
2420	IF TILE( XI, YJ ) > 127 OR TILE( XJ, YJ ) > 127 THEN YP = YP - CursorSpeed: YD = 0: YI=YP\8: YJ=(YP-CursorSpeed)\8
2430	GOTO 2450 ' roda o algoritmo da ponte por causa do risco de emparedamento na sala do easter egg

		' PONTE
		' unico cuidado que temos que tomar aqui é evitar que ao trocar de sala
		' usando a ponte, fiquemos emparedados
		' para otimizar, nao faremos isso aqui, pois teríamos que carregar a próxima tela
		' então vou marcar uma variável que será consultada na hora de trocar a tela
		' BRB = Bridge Rollback ou Be right back
		' Nao sei se vou fazer aqui mesmo;...
2450	IF YD > 0 AND YP >= 184 THEN BRBRP=RP: BRBYP=YP-CursorSpeed
2460	IF YD < 0 AND YP < 0 THEN BRBRP=RP: BRBYP=YP+CursorSpeed

2470	RETURN


' check X
2480 IF XD = 0 THEN 2490 ELSE IF XD > 0 THEN 2483
 	' XD < 0
	' easter egg: saindo da sala 3 se estiver depois do muro fino, ou saindo da sala do easter egg
2481 IF ( RP = 3 AND XP<=0 ) OR ( RP=4 AND OL(15)=4 ) THEN 2490 '  OR 
	' condicoes normais
2482 IF TILE( XI, YI ) > 127 OR TILE( XI, YJ ) > 127 THEN GOTO 2489 ELSE 2490

	' XD > 0 
	' easter egg
2483 IF RP=4 AND OL(15)=4 THEN GOTO 2490
	' condicoes normais (com cuidado para pular o logotipo nos caracteres 196-254)	
2485 IF ( TILE( XJ, YI ) > 127 AND TILE( XJ, YI ) < 192 ) OR ( TILE( XJ, YJ ) > 127 AND TILE( XJ, YJ ) < 192 ) THEN 2489 ELSE 2490

' cai aqui para cancelar parcialmente o movimento X (faltou o xp = xp + ou - cursorspeed
2489 XP = XP - CursorSpeed * sgn(xd): XI=XP\8: XJ=(XP-CursorSpeed*sgn(xd))\8: XD = 0

'
2490 RETURN



'
'
' acha prioridade do dragao I (TODO otimizar calculando apenas se alguem ou algo entra ou sai da sala)
'
' ARGUMENTO: I (dragão)
' LOCAL: JP, I7
' MODIFICA: PO(I) = 
'                     bit 8 (256) 0=persegue 1=foge
'                     bit 9 (512) 0=objeto nos bits 0-7 1=cursor
'                     bit 10 (1024) 0=prioridade definida 1=prioridade nao definida
'                     bits 0-7 (0-255) codigo do objeto
'
'

2500    FOR JP=0 TO 5
		' checa e trata o cursor (-1) na lista de prioridades
2510            I7 = PC(I,JP): IF I7=-1 THEN IF OL(I)=RP THEN PO(I)=512:GOTO 2550 ELSE 2540
		' PC(I,JP) já utiliza o bit 8 (256) como 0=persegue e 1=foge, então apenas propaga
2530            IF OL(I)=OL(I7 AND 255) THEN PO(I) = I7: goto 2550
2540    NEXT JP
        ' se chegou aqui, não existe prioridade na sala
2545    PO(I) = 1024
2550	RETURN

'
' redefine prioridades de todos os dragoes
'
2560 FOR I = 7 to 9
2570	GOSUB 2500
2580 NEXT I
2590 RETURN



'
' escolhe prioridade do imã
'
' LOCAL: JP, I7
' MODIFICA: OO
2600 FOR JP=0 TO 5
2610    I7=PC(4,JP)
2620    IF OL(4)=OL(I7) AND I7<>OP AND I7 <> OM THEN 2640 ' objeto está na mesma sala do imã e não está sendo carregado?
2630 NEXT JP : OO = -1 : GOTO 2650 ' sai se nao tem outro objeto na sala do ima
2640 OO = I7 
2650 RETURN




'
'
' rotinas de labirinto invisível
'
'

' desenha pedaco de linha x3-x4 na linha y0
' local: tmp, pom, vrm, k
3000 ParamDraw=1: Xinicial=x3: Xfinal=x4: Gosub 3500: Return

'
' desenha linha y3-y4 na coluna x0. Se 
' local: tmp, pom, vrm, k
'
3100 ParamDraw=1: Yinicial=y3:Yfinal=y4: Gosub 3400: Return

' apaga pedaco de linha x1-x2 na linha y0
' local: tmp, pom, vrm, k
3200 ParamDraw=0: Xinicial=x1: Xfinal=x2: Gosub 3500: Return

'
' apaga linha y1-y2 na coluna x0
' local: tmp, pom, vrm, k
'
3300 ParamDraw=0: Yinicial=y1:Yfinal=y2: Gosub 3400: Return

'
' desenha (ParamDraw=1) ou apaga (ParamDraw=0) linha Yinicial-Yfinal na coluna x0.
' local: tmp, pom, vrm, k
'
3400 tmp = x0 + Yinicial * 32
3405 gosub 3600 
3410 IncrementoDraw = 32
3420 for k = Yinicial to Yfinal
3430	gosub 3700
3460 next k
3470 return

' desenha (ParamDraw=1) ou apaga (ParamDraw=0) pedaco de linha Xinicial-Xfinal na linha y0
' local: tmp, pom, vrm, k
3500 tmp = Xinicial + y0 * 32
3505 gosub 3600 
3510 IncrementoDraw = 1
3520 for k = Xinicial to Xfinal
3530 	gosub 3700
3550 next k
3560 return

' procedure: seta pom, vrm e tmpdraw inicial a partir de tmp 
3600 pom = varptr( sc( 0,0 ) ) + tmp
3610 vrm = base(5) + tmp
3615 TmpDraw = 32
3620 return 

' procedure: miolo do for das rotinas 3400 e 3500
' PArametro: IncrementoDraw
3700	If ParamDraw=1 THEN TmpDraw = peek( pom ): pom = pom + IncrementoDraw
3720	vpoke vrm, TmpDraw
3730	vrm = vrm + IncrementoDraw
3740 return


'
' exibe labirinto invisível - atualiza tela se necessário
' global: xp,yp, xt0, yt0
' local: xj, yj , x1, x2, x3, x4, y1, y2, y3, y4

4000 xj=xp\8:yj=yp\8
4010 if (xj=xt0) and (yj=yt0) then 4290

4020 x3=xj-3: if x3<0  then x3=0
4030 y3=yj-3: if y3<0  then y3=0
4040 x4=xj+3: if x4>19 then x4=19
4050 y4=yj+3: if y4>23 then y4=23

' apaga borda antiga
4060 if x3 > x1 then x0 = x1: gosub 3300 
4070 if x4 < x2 then x0 = x2: gosub 3300 
4080 if y3 > y1 then y0 = y1: gosub 3200 
4090 if y4 < y2 then y0 = y2: gosub 3200 

' desenha nova borda
4130 if x4 > x2 then x0 = x4: gosub 3100 
4140 if x3 < x1 then x0 = x3: gosub 3100
4150 if y4 > y2 then y0 = y4: gosub 3000
4160 if y3 < y1 then y0 = y3: gosub 3000

' seta variaveis x1,x2,y1,y2 (uteis nas rotinas a seguir, e para detectar mudancas no futuro)
4200 x1=x3:y1=y3
4210 x2=x4:y2=y4
4220 xt0=xj:yt0=yj
4290 return

' exibe labirinto invisivel ao redor do cursor
' global: xt1, yt1, x1,x2,y1,y2
' local: pom, tmp, vrm
4300 '
4310 x1=xt1-3: if x1<0  then x1=0
4320 y1=yt1-3: if y1<0  then y1=0
4330 x2=xt1+3: if x2>19 then x2=19
4340 y2=yt1+3: if y2>23 then y2=23
4350 cls 
4360 ParamDraw = 1: Xinicial = x1: Xfinal = x2: For y0=y1 to y2
4370 	Gosub 3500
4380 next Y0
4390 return 

'
' PROCEDURE: rotina do morcego
'

5000 '

' morcego: voando (-X até -2)
5010 if oa(10)<-1 then oa(10)=oa(10)+1: goto 5070

' morcego: perseguindo objeto escolhido (oa(10)>=0) desde que esteja na mesma sala
5020 if oa(10)>=0 AND ol( oa(10) ) = ol( 10 ) then 5060

' escolhe um objeto da sala para o morcego perseguir (status -1)
' somente considera chaves (0-2), espada (3), imã (4), taça (5), ponte (6), dragões (7-9) e portal azul e laranja (16,17)
' armazena objetos na mesma sala no array SO e depois escolhe um aleatório
5030 i1=0
5035 for i=0 to 9 ' pula 10-15
5040 	if ol(i)=ol(10) and i<>om then so(i1)=i : i1=i1+1
5049 next i
5050 if i1>0 then oa(10) = so( int( rnd(1)*i1 ) ) else oa(10) = -1: goto 5070



' aponta na direcao do objeto escolhido (se chegou aqui, é certeza que está na mesma sala)
5060 vx(10) = sgn( ox( oa(10) ) - ox( 10 ) ) * BatSpeed:  vy(10) = sgn( oy( oa(10) ) - oy( 10 ) ) * BatSpeed

' segue voando na direcao determinada (exceto se está sendo seguro pelo jogador)
5070 if op<>10 then ox(10)=ox(10)+vx(10):oy(10)=oy(10)+vy(10): i1=10: gosub 7400

' se está segurando um objeto, move ele tambem
5072 If OM=-1 Then 5080
5074 If OP<>10 Then OX( OM ) = OX(10) + OW(10) + 4:OY(OM) = OY(10): OL( OM ) = OL( 10 )
5075 If OP=10  Then OX( OM ) = OX(OM) + XD*CursorSpeed:OY( OM )=OY( OM )+ YD*CursorSpeed ': I1=OM
5076 Gosub 7400

' se está segurando um dragao de barriga cheia, move o player
5078 IF OM>=7 and OM<=9 AND OA(OM)=-2 THEN Gosub 13300 : XP=OX(OM)+3:YP=OY(OM)+21:Gosub 5300:  If  RP <> OL(10) Then  RP=OL(10): Gosub 7000

' exibe o sprite do morcego e do objeto carregado
5080 Gosub 5200

' testa colisao com o objeto escolhido
5100 IF OA(10)<0 THEN 5150
5105    I2 = OA(10)
5110    IF OL(I2)<>OL(10) THEN 5150
5120	I1 = 10: GOSUB 6000: IF CO = 0 THEN 5150 

' colidiu: tira o objeto da mao do cursor, se for o caso
5130	IF OP = I2 THEN OP = -1

' ajusta posicao do objeto largado pelo morcego 
5135	I1 = OM : Gosub 7400 

' morcego segura objeto e seta o timer
5140    OM = I2 : OA(10)=-300 : OX( OM ) = OX( 10 ) + OW( 10 ) + 4 : OY( OM ) = OY( 10 ) 



' recalcula prioridade dos imãs (ja que objetos foram soltos)
5147 GOSUB 2600

5150 '
5190 return

'
' Procedure: Exibe e anima sprite do morcego
' num frame ele tem 2 sprites, no outro, 1, por isso eu apago e ajusto a altura
'
5200 if ( fr mod 20 ) < 10 then os(10)=24: oh(10)=20 else os(10)=26: oh(10)=16:SprCamada=20:gosub 7895
5210 I7 = 10 : IF OL(10)=RP THEN X7=OX(10):Y7=OY(10) ELSE Y7=207
5220 GOSUB 7800
' exibe o objeto segurado, se houver
5230 IF OM = -1 THEN 5260
5240 I7=OM : IF OL(OM) = RP THEN X7=OX(OM):Y7=OY(om) ELSE Y7=207
5250 GOSUB 7800
5260 RETURN 

'
' Procedure: exibe o cursor
'
5300 IF FR MOD 2 then TmpX = XP: TmpY = YP ELSE TmpX = UX: TmpY = UY
5310 PUTSPRITE 0,(TmpX,TmpY),11,0
5320 RETURN


'
' procedure: testa colisao entre boxes do objeto I1 (-1=cursor) e objeto I2 
' retorna: co
'
6000 CO = 0
6005 IF I1 = -1 AND RP <> OL(I2) THEN 6060
6010 IF I1 <> -1 AND OL(I1) <> OL(I2) THEN 6060

6020 if I1 = -1 then OXi1 = XP : OWi1 = 4: OYi1 = YP : OHi1 = 8 else OXi1 = ox(i1): OWi1 = ow(i1): OYi1 = oy(i1): OHi1 = oh(i1)
6025 OXI2 = OX(I2): OYI2 = OY(I2)
6030 CO = ( OXi1 + OWi1 ) > OXI2 and OXi1 <= ( OXI2 + OW(i2) ) and ( OYi1 + OHi1 ) >= OYI2 and OYi1 <= ( OYI2 + OH(i2) )

' colisão com ponte - lado direito
6040 IF I2<>6 OR CO<>0 THEN 6060
6050 CO = OXI2 <= ( OXi1-32+OWi1 ) AND OXI2 >= ( OXi1-40 ) AND OYI2 >= ( OYi1 - OH(I2) ) AND OYI2 <= OYi1+OHi1
6060 RETURN

'
' procedure: player tocou o dragao i2. precisa de xd e yd indicando a direcao
' caso o movimento nao seja valido, modifica xp,yp, xd e yd apropriadamente
'

' pança cheia - cancela todos os movimentos
6100 CancelaAmbosMovimentos = 0: if oa(i2) = -2 then CancelaAmbosMovimentos = 1 : GOTO 6170

6105 oyi2=oy(i2):oxi2=ox(i2)

' se dragao está em status persegue (chase) e toca player, passa para o estado mordendo (biting)
' dragao vermelho (9) passa menos tempo mordendo
6110   if oa(i2)=0 then oa(i2)=25 + ( i2=9 ) * 10: os(i2)=12: ox(i2)=xp-2: oy(i2)=yp-2: CMD PLYSOUND 4,0,15: goto 6195

' dragao morto - colisão
6115   if oa(i2)<>-1 then 6160 

' bico levantado
6116       if yp > oy(i2) then 6120
6117	   if xd =  1 and xp >= ( oxi2 + 2 ) then 6170
6118	   if xd = -1 and xp >  ( oxi2 + 2 ) and  xp <= ( oxi2 + 7 ) then 6170
6119       goto 6199

' resto do corpo
6120       if xd =  1 and (xp + 4) >= oxi2   then 6170
6130       if xd = -1 and xp < (oxi2+ow(i2)) then 6170
6140       if yd =  1 and (yp + 4) >= oyi2   then 6180
6150       if yd = -1 and yp < (oyi2+oh(i2)) then 6180
6155       goto 6199

6160   ' hitbox do dragao biting (mordendo)
' boca aberta
6162	if yp > (oyi2+16) then 6120 ' o hitbox do corpo é o mesmo mordendo e morto
6164	   if xd =  1 and xp >= ( oxi2 + 3 ) then 6170
6166	   if xd = -1 and xp >  ( oxi2 + 3 ) and  xp <= ( oxi2 + 7 ) then 6170
6168       if yd = -1 and xp <  ( oxi2 + 4 ) then 6180
6169       if yd = +1 and xp <  ( oxi2 + 4 ) and yp >= ( oyi2 + 5 ) then 6180

	' cancela XD 
6170 XP = XP - CursorSpeed * XD: XD = 0 : IF CancelaAmbosMovimentos = 0 THEN goto 6195

	' cancela YD
6180 YP = YP - CursorSpeed * YD: YD = 0 : goto 6195

6195   i7=i2:x7=oxi2:y7=oyi2:gosub 7800
6199   return


'
' Procedure: dragao fechou a boca - checa se mordeu 
'
' Modifica: XP, YP, ES, EC
' LOCAL: oyi2, oxi2, I7, X7, Y7
'
6200 ' dragao i2 fecha a boca; checa se comeu o cursor
6205 oyi2 = oy(i2) : oxi2 = ox(i2)
6210 if not( OL(I2) = RP AND xp >= ( oxi2 - 1 ) AND xp <= ( oxi2 + 4 ) and yp >= oyi2 and yp <= ( oyi2 + 5 ) ) then goto 6250
6220 	xp = oxi2 + 3 : yp = oyi2 + 21 : oa(i2) = -2 : os(i2) = 9
6230 	i7 = i2 : x7 = oxi2 : y7 = oyi2 : gosub 7800
6235		CMD PLYSOUND 2,0, 15 ' efeito sonoro
6236		'locate 20,11 : print "Pressione F1" ' TODO - dar mais destaque
6240 goto 6290
	' nao mordeu o cursor - volta a caça!
6250 os(i2) = 9
6290 return



'
' Procedure: seta cor do tile de muro fino (para implementar easter egg)
'
' local: TMP, ITMP, ObjetosNaSala4
'
'6800 IF RP = 4 AND OL(15) = 4 THEN TMP = 238 ELSE TMP = 30 'TMP = 14*16+14 ELSE TMP = 1*16+14
6800 TMP = 30 ' preto sobre cinza 1*16 + 14
6810 IF RP <> 4 OR OL(15) <> 4 THEN 6850
' está na sala 4 com o ponto cinza. se tiver mais dois objetos, ativa o easter egg
6815 ObjetosNaSala4 = 0
6820 FOR ITMP = 0 TO 6
6830 	IF OL( ITMP ) = 4 THEN ObjetosNaSala4 = ObjetosNaSala4+1
6840 NEXT ITEMP
6845 IF ObjetosNaSala4 >= 2 THEN TMP = 238 : Gosub 13200 ' cinza sobre cinza 14*16+14
6850 VPOKE BASE(6)+17, TMP
6860 RETURN

'
' Procedure: nova vida (equivalente a apertar o reset no atari)
' - volta para frente do castelo
' - revive os dragões
' - perde objeto carregado
'
6900 RP=1
6910 XP=76
6920 YP=160
6930 OP=-1
6940 for i=7 to 9
6950	oa(i)=0
6960	os(i)=9
6970 next i
6980 return


'
' Procedure: exibe a sala RP
'
'

7000 CLS

7002 CMD DISSCR

7005 ColRoom = RC(RP): ColBg = 14 
	
7009 vpoke base(6)+19,254
	
	' seta cores da sala e do muro fino (6800) ( e do espaço) 
7010 VPOKE BASE(6)+16, (ColRoom * 16) + ColBg: vpoke base(6) + 4, 16+ ColBg : GOSUB 6800 

' desenha sala genérica
7013 RLRP = RL(RP): RFRP = RF(RP) 
7015 IF (RLRP AND 128) = 0 THEN 7040
7020 R = RLRP and 127

' desenha salas especificas (castelo, labirinto)
7025 SCREEN LOAD 1 + R ' ResCastle+R

7030 IF R = 0 AND ( RFRP AND 1 ) = 0 then GOSUB 7900

7035 goto 7090

' sala normal
7040 BAASE5 = Base(5): FOR I=0 TO 19 : I8a11 = (i>=8 and i<=11)

' saida norte
7045 tmp=128+96*((RLRP AND 4)<>0 and I8a11): vpoke BAASE5, tmp: vpoke BAASE5+32, tmp

' saida sul (22*32=704)
7050 tmp=128+96*((RLRP AND 8)<>0 and I8a11): vpoke BAASE5+704, tmp: vpoke BAASE5+736, tmp

7055 BAASE5=BAASE5+1: NEXT I

' caractere das saidas laterais depende do 5 bit
7060 TMP = 128 - 8*((RLRP AND 16)<>0)

7070 Baase5 = Base(5) + 64: FOR i = 2 to 21: vpoke Baase5,-tmp*((RLRP and 2)<>2): vpoke Baase5+19,-tmp*((RLRP and 1)<>1): Baase5=Baase5+32:next i

' apaga sprite da porta
7090 SprCamada=12:GOSUB 7895:SprCamada=23:GOSUB 7895 

' se estou no nivel zero e na sala 4, transfere o portal 1 para lá
7092 IF LV = 0 AND RP = 4 THEN GOSUB 400

' se estou no nivel zero e na sala 1, transfere o portal 1 para lá
7095 IF LV = 0 AND RP = 1 THEN GOSUB 450

' exibe ou esconde objetos
7100 GOSUB 7600

' se estou no labirinto no nivel zero, labirinto pacman - mostra os pontinhos
7105 IF LV = 0 AND RP >=9 AND RP <= 13 THEN GOSUB 11000


' salva tela no array para labirinto invisivel e otimização de colisão
7110 SCREEN COPY TO SC

' seta xt1, yt1 e sc para labirinto invisivel
7120 IF ( RFRP AND 2 ) = 0 THEN 7150
7130 	xt1 = xp \ 8: yt1 = yp \ 8 
7140 	GOSUB 4300

' marca para redefinir prioridades dos dragoes e imãs
7150 CALCULAPRIORIDADES = 1

' desenha logotipo do jogo (e tela de status)
7160 CMD RESTORE 27 ' ResChrTitle
7164 IRESTORE 0
7165 FOR i=0 to 23
7166	FOR j=0 to 11
7167	IREAD a
7168	PUT TILE a,( 20+j, i )
7169	NEXT J
7170 NEXT I

' mostra conquistas
7180 Gosub 14500

' fim da rotina
7190 CMD ENASCR
7200 RETURN

' comando: /A (aleatoriza posicao dos elementos 0-10)
7210 FOR i=0 to 10
7211	TMP = INT( RND(1) * 31 ): RFTMP=RF(TMP)
7213	IF (RFTMP AND ObjetoSalaFlag(i)) OR ( RFTMP AND 128 ) THEN 7211
7219	OL( I ) = TMP
7220 NEXT I
7225 RETURN


' muda para jogo "T"
' se T=1 ou 2, LV=T
' se T=3, LV=2 e roda aleatorização na inicializacao
7230 IF T=1 OR T=2 THEN LV=T:AL=0
7235 IF T=3 THEN LV=2: AL=1
7236 IF T=4 THEN LV=3: AL=0
7237 RETURN


'
'
' PROCEDURE: muda objeto i1 de sala se for preciso
'
' LOCAL OLI1
'
7400 OLI1 = OL(I1): OxI1 = OX( I1 ) : OyI1 = OY( I1 )
7410	IF OxI1 >= 160 then OX(I1)=OxI1-160: SALA = RE( OLI1 ): GOTO 7480

7420	IF OxI1 <    0 then OX(I1)=158+OxI1: SALA = RO( OLI1 ): GOTO 7480

7430    IF OyI1 <    0 THEN OY(I1)=184+OyI1: SALA = RN( OLI1 ): GOTO 7480

		' saida para baixo
		' BUG: ao sair da sala 1 com a espada ao lado do cursor, a espada sofre shift no eixo Y
7440    IF OyI1 <= 184 THEN 7450
			' objeto segurado
7442 		SALA = RS( OLI1 ) 
			' saida para castelo
			'             OL( I1 )             => sala atual => entrada do castelo
			'         RF(     "    )           => propriedades da entrada do castelo
			'       (         "      ) \ 256   => objeto porta da entrada do castelo
			'   OA(           "              ) => propriedades da porta do castelo
			' (               "                ) AND 255 => sala para onde vai a porta do castelo
			' regra => se eu saí do castelo, entao começo no meio da tela
7443		IF RL( SALA )=128 AND ( OA( RF( SALA ) \ 256 ) AND 255 ) = OLI1 THEN OY(I1)=OyI1-66 ELSE OY(I1)=OyI1-184
7444		GOTO 7480

7450    IF RL(OL(I1))<>128 OR OP = I1 THEN 7490 ' abaixo, regras para entrada no castelo (exceto se o objeto estiver sendo seguro)
7455		PORTA = RF( OLI1 ) \ 256 ' objeto porta correspondente

' Testa se a porta tá aberta
7460		IF ( OA( PORTA ) AND 256 ) = 0 THEN 7490

7465		IF OxI1+OW(I1)>=76 AND OxI1<=86 AND OY(I1)+OH(I1)>=111 AND OY(I1)<=117 THEN OL(I1)=OA(PORTA) and 255:OY(I1)=184

7470		GOTO 7490

' mudança de sala dos objetos segurados (exceto se estiver entrando e saindo do castelo - ver 7460-7474)
7480 IF OP=I1 and OLI1<>RP THEN OL(I1)=RP ELSE OL(I1)=SALA

' seta para recalcular prioridades dos dragoes (TODO se eles estiverem nas salas afetadas?)
7485 CALCULAPRIORIDADES = 1

' se o objeto mudou de sala, e a sala anterior era a do jogador, apaga sprite
7490 IF OL(I1) <> OLI1 AND OLI1 = RP THEN I7=I1:X7=OxI1:Y7=207: GOSUB 7800

' easter egg
7492 IF I1 = 15 AND RP = 4 THEN GOSUB 6800

7495 RETURN

'
' PROCEDURE: animacao do final de nível
'
' toca linda canção de fim de jogo
7500 CMD PLYLOOP 0
7505 CMD PLYSONG 2
7507 CMD PLYPLAY

' faz bonita animação 
7510 FOR I=0 TO 200
7520    COLOR (I MOD 14)+1
7530    TIME =0
7570    IF TIME=0 THEN 7570
7580 NEXT I
7590 RETURN

'
'
' procedure: exibe objetos existentes na sala RP, esconde os outros
'
' GLOBAL: OO, TemPorta, ePorta
' LOCAL: I7, X7, Y7
'
' no nivel zero, exibe os portais
7600 OO=-1
7605 TemPorta = 0
7610 FOR I7=0 TO 17
' se é uma porta e ela existe na sala , seta flag
7615	ePorta = ( I7 >= 11 AND I7 <= 13): if ePorta AND OL(I7) = RP THEN TemPorta = 1
7620	IF OL(I7) <> RP THEN X7=0: Y7=207 : GOTO 7635
7625		X7=OX(I7):Y7=OY(I7)
' seta o objeto preferencial do imã (oo)
7630		IF I7<>4 AND OP<>I7 AND I7<7 THEN OO=I7
' se é uma porta e é pra apagar, nao roda o algoritmo		
7635	IF ePorta and Y7=207 then 7650
7640    GOSUB 7800
7650 NEXT I7
' se a flag nao foi setada, apaga a porta (qualquer uma, pois todas tem mesma camada)
7660 IF  TemPorta=0 then i7=11: y7=207: Gosub 7800
7690 RETURN

' procedure: atrai objeto OO para o ima
' local: x7,y7,dx,dy,i7
7700 IF OO=-1 THEN goto 7760
7710 IF OL(OO) <> OL(4) THEN GOSUB 2600: GOTO 7700 ' se objeto nao ta na mesma sala do ima, recalcula prioridade
7725    X7=OX(4):Y7=OY(4)
7730    DX=SGN( (OX(OO)-X7)\2 )*MagnetSpeed:DY=SGN( ( OY(OO)-16-Y7 )\2 )*MagnetSpeed
7740    OX(OO)=OX(OO)-DX
7750    OY(OO)=OY(OO)-DY
7751    I1=OO: GOSUB 7400
7755    IF RP=OL(OO) THEN I7=OO:X7=OX(OO):Y7=OY(OO):GOSUB 7800
7760 RETURN

'
'
'
' procedure: exibe/oculta objeto i7 na posicao x7,y7
'
' Local: XPonte, SprCamada, OS1
'
7800 IF I7 >= 14 THEN 7850

' regra para sprites de 0 a 10 => SprCamada = I7 + 1
' regra para portas (11-13) => SprCamada = 12
7805 SprCamada = I7 + 1 : IF I7 >= 11 Then SprCamada = 12
7807 PUTSPRITE SprCamada,(X7,Y7),OC(I7),OS(I7)

' regra para sprites duplos
7810 IF OH(I7) <=16 THEN RETURN
7815 SprCamada = I7 + 10: OS1=OS(I7)+1 : IF I7 >= 11 Then SprCamada = 23 : OS1=OS(I7)
7817 IF  Y7<>207 THEN  PUTSPRITE SprCamada,(X7,Y7+16),OC(I7),OS1 ELSE GOSUB 7895

' regra para sprites triplos (dragao e ponte)
7820 IF OH(I7) <= 32 THEN RETURN
7825 SprCamada = I7 + 19: IF Y7<>207 THEN PUTSPRITE SprCamada,(X7,Y7+32),OC(I7),OS(I7)+2 ELSE GOSUB 7895

' desenha lado direito da ponte
7830 IF I7<>6 THEN RETURN
7835 XPonte = X7 + 32: PUTSPRITE 29,(XPonte,Y7),OC(I7),OS(I7)+3
7840 IF Y7<>207 THEN PUTSPRITE 30,(XPonte,Y7+16),OC(I7),OS(I7)+4 : PUTSPRITE 31,(XPonte,Y7+32),OC(I7),OS(I7)+5 ELSE SprCamada=30: GOSUB 7895 : SprCamada=31: GOSUB 7895
7845 RETURN

' regra para portal e gray dot / portal 2 e 3
7850 IF I7 = 14 OR I7 = 15 THEN SprCamada = 13 ELSE SprCamada = 5+I7

7880 putsprite SprCamada,( x7, y7 ), oc(i7), os(i7)

7890 RETURN

' procedure: esconde sprite na camada SprCamada
7895 PUTSPRITE SprCamada,(0,207): RETURN



'
'
' procedure: abre porta do castelo (apaga os caracteres que impedem a entrada)
'
'
7900 FOR I=14 TO 17
7910	PUT TILE 32,(9,I): PUT TILE 32,(10,I)
7920 NEXT I
7930 SCREEN COPY TO SC
7940 RETURN

'
'
' procedure: read vram 
'
'

	' define caracteres (TODO utilizar algum RESOURCE para economizar memoria)
8000 BLOAD "chars\ADVCHR.SC1",S 

    ' Load sprite resource
8010 CMD WRTSPR 0 ' ResSprte


	' seta ObjetoSalaFlag
8300 CMD RESTORE 39
8310 IRESTORE 0
8320 FOR I = 0 to 10
8340 	IREAD ObjetoSalaFlag(i)
8350 NEXT I


8400 RETURN



'
'
' procedure: le mapa da fase atual, objetos e preferencias
'
'
9000 CMD RESTORE 30 + LV ' ResRooms+LV
9010 irestore 0
9020 for i = 0 to 31
9030 	iread rl(i),rc(i),rs(i),rn(i),re(i),ro(i),rf(i)
9040 next i

	' le objetos
9100 CMD RESTORE 34 + LV ' ResObjects+LV
9120 irestore 0
9130 for i = 0 to 18
9140	iread OL(i),OX(i),OY(i),OC(i),OS(i),OH(i),OW(i),OA(i),vx(i),vy(i)
9160 next i

	' objetos preferidos pelos dragoes e pelo ima
	' status dragao: -2 comeu cursor -1 morto (dead) 0 caça (chase) >1 biting (o numero funciona como um contador)
9200 CMD RESTORE 38 ' ResObjPref
9210 IRESTORE 0
9220 FOR I = 0 to 9
9230	IREAD INDICE
9240	FOR J = 0 to 5
9250		IREAD PC( I, J )
9260	NEXT J
9270 NEXT I

	' fim
9980 RETURN

'
' PROCEDURE: Prepara labirinto pacman
'
10000 '
10010 FOR R = 9 TO 13
10020 SCREEN LOAD R - 7 ' ResLayouts+(R-9)
10030 I=0: Baase5 = Base(5)
10040   IF ( I AND 31 ) < 20 THEN TMP = VPEEK(Baase5): IF TMP = 32 THEN VPOKE Baase5, 46
10050   I = I + 1: Baase5 = Baase5 + 1
10055 IF I < 767 THEN 10040
10060 CMD VRAMTORAM Base(5), VarPtr( PacManSc(0,R-9) ), 768
10070 NEXT R
10080 RETURN

' exibe tela do labirinto (em ram para preservar os pontos)
11000 '
11010 CMD RAMTOVRAM VarPtr( PacManSc(0,RP-9) ), Base(5), 768 
11020 RETURN

' prepara labirinto pacman para direcionar para saída
11100 ' Eu queria apagar os pontinhos mas economia de espaço (191 bytes bicho)
11120 FOR R=0 to 4: Poke VarPtr( PacManSc( 0, R ) ) + 39, 137 : NEXT R
11130 Poke VarPtr( PacManSc( 0, 1 ) ) + 39, 140
11140 return


' colisao com as bolinhas do labirinto
12000 TmpX = XP \ 8: TmpY = YP \ 8
12005 IF PacManCount > 0 then PacManCount = PacManCount - 1
12010 IF TILE( TmpX, TmpY ) <> 46 THEN 12090
12030 PUT TILE 32, ( TmpX, TmpY )
12040 IF PacManCount = 0 THEN CMD PLYSOUND 6,1,15: PacManCount = 3 ' efeito sonoro 
12050 PacDots = PacDots - 1: LOCATE 23,12:Print PacDots : if PacDots = 0 then gosub 12200
12070 POKE VarPtr( PacManSc(0,RP-9) ) + TmpX + TmpY * 32, 32
12090 RETURN 

' pisca as setinhas pois terminou o labirinto
12100 vpoke base(6)+17, ( fr and 15 ) * 16 + 13
' deixa o dragão amarelo sussa pra dar paz pra aprender a usar a portal gun
12110 oa(7) = -1
12120 RETURN

'
' PROCEDURE: finalizou a fase do pacman
'

	' limpa o labirinto dos pontinhos, coloca setinhas e cria saída pra sala do dragão
12200 RN(13)=14: gosub 11100: gosub 7000: PacDots = -1 ' pacdots do final
12210 return

'
'
' rotinas de conquistas
'
'

' rotina: verifica conquistas de terminar o castelo
' chamar ao terminar o castelo
' - 0 (terminou um nível sem matar dragoes)
13000 IF Conquistas(0) = 0 AND DragoesMortos = 0 THEN ConseguiuConquista = 0: gosub 14000

' - 3 (taça atraída para o castelo)
13010 IF Conquistas(3) = 0 AND OO=5 THEN ConseguiuConquista=3 : gosub 14000

' - 4 (acumulou todos os objetos no castelo)
13020 IF Conquistas(4) <> 0 THEN 13050
13030 FOR TmpObjeto = 0 to 6: IF OL( TmpObjeto ) <> 0 THEN 13050
13040 NEXT TmpObjeto : ConseguiuConquista = 4: gosub 14000

' - 5 (terceirização - o morcego levou a taça pro castelo) 
13050 IF Conquistas(5) = 0 AND OM=5 THEN ConseguiuConquista=5 : gosub 14000
13060 return


' rotina: verifica conquista 1 (matou todos os dragoes)
' chamar ao matar um dragão
13100 IF Conquistas(1) = 0 AND OA(7)=-1 and OA(8)=-1 and OA(9)=-1 THEN ConseguiuConquista = 1: gosub 14000
13110 return

' rotina: verifica conquista 2 (easter egg) (já deve ser chamado após a verificação)
13200 IF Conquistas(2) = 0 THEN ConseguiuConquista=2: gosub 14000
13210 return

' rotina: verifica conquista 6 (passeio na barriga do dragão)
' chamar ao ser movido na rotina do morcego
13300 IF Conquistas(6) = 0 THEN ConseguiuConquista=6 : gosub 14000
13310 return

' rotina: verifica conquista 7 (terminou o castelo IV)
13400 IF Conquistas(7) = 0 THEN ConseguiuConquista=7 : gosub 14000
13410 return

' rotina: marca a conquista, faz uma graça
' TODO fazer graça
14000 Conquistas( ConseguiuConquista ) = 1
14010 gosub 14500
14020 return

' rotina: exibe conquistas
14500 FOR i=0 to 7
14510 	IF Conquistas(i) THEN VPOKE base(5) + i + 342, 144+i
14520 NEXT i
14530 RETURN 